#!/usr/bin/python

import os
import stat
import errno
import fuse
import psycopg2

fuse.fuse_python_api = (0, 2)

connectstring = "dbname='snapshot' user='snapshot' host='localhost' password='x'"

def make_farm_link(hash):
   prefix1 = hash[0:2]
   prefix2 = hash[2:4]
   return os.path.join("/srv/snapshot/farm", prefix1, prefix2, hash)

class MyStat(fuse.Stat):
   def __init__(self):
      self.st_ino = 0
      self.st_dev = 0
      self.st_uid = 0
      self.st_gid = 0
      self.st_atime = 0
      self.st_mtime = 0
      self.st_ctime = 0

      self.st_mode = 0
      self.st_size = 0
      self.st_nlink = 1

class DirStat(MyStat):
   def __init__(self, subdirs=None, ctime=0, mtime=0):
      MyStat.__init__(self)
      self.st_mode = stat.S_IFDIR | 0755
      if subdirs is None:
         self.st_nlink = 1 # unknown
      else:
         self.st_nlink = 2+subdirs
      self.st_size = 4096
      self.st_ctime = ctime
      self.st_mtime = mtime

class SymlinkStat(MyStat):
   def __init__(self, len, ctime=0, mtime=0):
      MyStat.__init__(self)
      self.st_mode = stat.S_IFLNK | 0777
      self.st_size = len
      self.st_ctime = ctime
      self.st_mtime = mtime

class SnapshotDB():
   def __init__(self):
      self.db=psycopg2.connect(connectstring)

   def query(self, *args, **kw):
      c = self.db.cursor()
      c.execute(*args, **kw)
      return c.fetchall()

   def query_firsts(self, *args, **kw):
      all = self.query(*args, **kw)
      return map(lambda x: x[0], all)


def split_path(path):
   path_elements = path.split('/',2)[1:]
   if len(path_elements) == 1:
      subpath = '/'
   else:
      subpath = '/'+path_elements[1]
   return(path_elements[0], subpath)

class SnapshotFile():
   def __init__(self, db, parent_dir, timestamp, name):
      self.db = db
      self.parent_dir = parent_dir
      self.timestamp = timestamp
      self.name = name

      list = self.db.query("""SELECT hash,
                                     extract(epoch from first_run) as ctime,
                                     extract(epoch from last_run) as mtime
                              FROM file NATURAL JOIN node_with_ts
                              WHERE parent=%(parent_dir)s
                                AND first_run <= %(timestamp)s
                                AND last_run  >= %(timestamp)s
                                AND name = %(name)s
                           """,
                           {'parent_dir': self.parent_dir,
                            'timestamp': self.timestamp,
                            'name': name});
      if len(list) == 0:
         raise IOError(errno.ENOENT, 'No such directory')
      elif len(list) > 1:
         raise IOError(errno.EIO, 'Multiple hits for regular file - FS corrupt?')

      self.hash = list[0][0]
      self.ctime = list[0][1]
      self.mtime = list[0][1]
      self.target = make_farm_link(self.hash)

   def getattr(self):
      return SymlinkStat(len(self.target), self.ctime, self.mtime)
   def readlink(self):
      return self.target


class SnapshotSymlink():
   def __init__(self, db, parent_dir, timestamp, name):
      self.db = db
      self.parent_dir = parent_dir
      self.timestamp = timestamp
      self.name = name

      list = self.db.query("""SELECT target,
                                     extract(epoch from first_run) as ctime,
                                     extract(epoch from last_run) as mtime
                              FROM symlink NATURAL JOIN node_with_ts
                              WHERE parent=%(parent_dir)s
                                AND first_run <= %(timestamp)s
                                AND last_run  >= %(timestamp)s
                                AND name = %(name)s
                           """,
                           {'parent_dir': self.parent_dir,
                            'timestamp': self.timestamp,
                            'name': name});
      if len(list) == 0:
         raise IOError(errno.ENOENT, 'No such directory')
      elif len(list) > 1:
         raise IOError(errno.EIO, 'Multiple hits for symlink - FS corrupt?')

      self.target = list[0][0]
      self.ctime = list[0][1]
      self.mtime = list[0][1]

   def getattr(self):
      return SymlinkStat(len(self.target), self.ctime, self.mtime)
   def readlink(self):
      return self.target


class SnapshotDirectory():
   def __init__(self, db, archive_id, timestamp, path):
      self.db = db
      self.archive_id = archive_id
      self.timestamp = timestamp
      self.path = path

      list = self.db.query("""SELECT directory_id,
                                     extract(epoch from first_run) as ctime,
                                     extract(epoch from last_run) as mtime
                              FROM directory NATURAL JOIN node_with_ts
                              WHERE path=%(path)s
                                AND archive_id = %(archive_id)s
                                AND first_run <= %(timestamp)s
                                AND last_run  >= %(timestamp)s""",
                           {'archive_id': self.archive_id,
                            'path': self.path,
                            'timestamp': self.timestamp})
      if len(list) == 0:
         raise IOError(errno.ENOENT, 'No such directory')
      elif len(list) > 1:
         raise IOError(errno.EIO, 'Multiple hits for directory - FS corrupt?')

      self.directory_id = list[0][0]
      self.ctime = list[0][1]
      self.mtime = list[0][2]

   def getattr(self, name=None):
      if name is None:
         # the getattr is about the directory itself
         st = DirStat(None, self.ctime, self.mtime)
         return st
      else:
         # not this directory but a element (not a subdir) in it

         # so maybe it's a regular file
         try:
            return SnapshotFile(self.db, self.directory_id, self.timestamp, name).getattr()
         except IOError, e:
            if e.errno != errno.ENOENT: raise

         # or maybe it's a symlink:
         try:
            return SnapshotSymlink(self.db, self.directory_id, self.timestamp, name).getattr()
         except IOError, e:
            if e.errno != errno.ENOENT: raise

         return -errno.ENOENT

   def readdir(self, offset):
      # all subdirs:
      subdirs = self.db.query_firsts("""SELECT path
                                        FROM directory NATURAL JOIN node_with_ts
                                        WHERE parent=%(parent_dir)s
                                          AND directory_id <> parent
                                          AND first_run <= %(timestamp)s
                                          AND last_run  >= %(timestamp)s
                                     """,
                                    # the / directory has itself listed as parent - we never want to
                                    # get that returned
                                     {'parent_dir': self.directory_id,
                                      'timestamp': self.timestamp});
      others = self.db.query_firsts("""  SELECT name FROM file NATURAL JOIN node_with_ts
                                         WHERE parent=%(parent_dir)s
                                           AND first_run <= %(timestamp)s
                                           AND last_run  >= %(timestamp)s
                                       UNION ALL
                                         SELECT name FROM symlink NATURAL JOIN node_with_ts
                                         WHERE parent=%(parent_dir)s
                                           AND first_run <= %(timestamp)s
                                           AND last_run  >= %(timestamp)s
                                    """,
                                    {'parent_dir': self.directory_id,
                                     'timestamp': self.timestamp});
      subdirs = map(lambda x: os.path.basename(x), subdirs)
      subdirs.extend(others)
      return subdirs

   def readlink(self, name):
         try:
            return SnapshotFile(self.db, self.directory_id, self.timestamp, name).readlink()
         except IOError, e:
            if e.errno != errno.ENOENT: raise

         try:
            return SnapshotSymlink(self.db, self.directory_id, self.timestamp, name).readlink()
         except IOError, e:
            if e.errno != errno.ENOENT: raise

         return -errno.ENOENT

class MirrorRun():
   def __init__(self, db, archive_id, timestamp):
      self.db = db
      self.archive_id = archive_id
      self.timestamp = timestamp

   def getattr(self, path):
      try:
         return SnapshotDirectory(self.db, self.archive_id, self.timestamp, path).getattr()
      except IOError, e:
         if e.errno != errno.ENOENT: raise

      parentpath = os.path.dirname(path)
      basename = os.path.basename(path)
      return SnapshotDirectory(self.db, self.archive_id, self.timestamp, parentpath).getattr(basename)

   def readdir(self, path, offset):
      return SnapshotDirectory(self.db, self.archive_id, self.timestamp, path).readdir(offset)

   def readlink(self, path):
      parentpath = os.path.dirname(path)
      basename = os.path.basename(path)
      return SnapshotDirectory(self.db, self.archive_id, self.timestamp, parentpath).readlink(basename)

class FSStaticElement():
   def __init__(self):
      self.elements = {}

   def getattr(self, path):
      (first, subpath) = split_path(path)
      if first == '':
         return DirStat(len(self.elements))
      elif first in self.elements:
         return self.elements[ first ].getattr(subpath)
      return -errno.ENOENT

   def readdir(self, path, offset):
      (first, subpath) = split_path(path)
      if first == '':
         return self.elements.keys()
      elif first in self.elements:
         return self.elements[ first ].readdir(subpath, offset)
      return -errno.ENOENT

   def readlink(self, path):
      (first, subpath) = split_path(path)
      if first == '':
         return -errno.EINVAL
      elif first in self.elements:
         return self.elements[ first ].readlink(subpath)
      return -errno.ENOENT

class Archive(FSStaticElement):
   def __init__(self, db, id):
      FSStaticElement.__init__(self)
      self.db = db
      self.id = id
      self.load_elements()

   def load_elements(self):
      list = self.db.query("""SELECT run, to_char(run, 'YYYYMMDD"T"HH24MISS')
                              FROM mirrorrun
                              WHERE archive_id=%(id)s""", {'id': self.id})
      for e in list:
         timestamp = e[0]
         pretty_timestamp = e[1]
         self.elements[pretty_timestamp] = MirrorRun(self.db, self.id, timestamp)


class Root(FSStaticElement):
   def __init__(self, db):
      FSStaticElement.__init__(self)
      self.db = db
      self.load_elements()

   def load_elements(self):
      list = self.db.query('SELECT archive_id, name FROM archive')
      for e in list:
         id = e[0]
         name = e[1]
         self.elements[name] = Archive(self.db, id)


class SnapshotFS(fuse.Fuse):
   def __init__(self, root, *args, **kw):
      fuse.Fuse.__init__(self, *args, **kw)
      self.root = root

   def getattr(self, path):
      return self.root.getattr(path)

   def readdir(self, path, offset):
      dirents = [ '.', '..' ]
      dirents.extend( self.root.readdir(path, offset) )
      for r in dirents:
         yield fuse.Direntry(r)

   def readlink(self, path):
      return self.root.readlink(path)

def main():
   db = SnapshotDB()
   root = Root(db)

   server = SnapshotFS(root, dash_s_do='setsingle')
   server.parse(errex=1)
   server.main()

if __name__ == '__main__':
   main()

# vim:set et:
# vim:set ts=3:
# vim:set shiftwidth=3:
