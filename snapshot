#!/usr/bin/ruby

# Copyright (c) 2009 Peter Palfrader
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


require 'optparse'
require 'yaml'
require 'dbi'
require 'logger'
require 'digest/sha1'

def barf(str)
	STDERR.puts str
	exit 1
end

class SnapshotDB
	def initialize(conf)
		@dbh = DBI.connect("dbi:Pg:#{conf['database']}:#{conf['host']}", conf['user'], conf['password'], 'AutoCommit'=>false)
	end

	def get_primarykey_name(table);
		# XXX
		return table+'_id';
	end


	def begin()
		@dbh.do("BEGIN")
	end
	def commit()
		@dbh.do("COMMIT")
	end

	def dbdo(query, *args)
		begin
			@dbh.do(query, *args)
		rescue DBI::ProgrammingError
			STDERR.puts("DB Error: #{$!}")
			STDERR.puts("Query: #{query}")
			STDERR.puts("Arguments: #{args.join(', ')}")
			raise
		end
	end
	def execute(query, *args)
		begin
			@dbh.execute(query, *args)
		rescue DBI::ProgrammingError
			STDERR.puts("DB Error: #{$!}")
			STDERR.puts("Query: #{query}")
			STDERR.puts("Arguments: #{args.join(', ')}")
			raise
		end
	end

	def insert(table, values, returning=nil)
		cols = values.keys().join(',')
		vals = values.values()
		qmarks = (['?'] * values.length).join(',')

		query = "INSERT INTO #{table} (#{cols}) VALUES (#{qmarks})"

		if returning.nil?
			dbdo(query, *vals)
			return nil
		else
			returning = [returning] unless returning.kind_of?(Array)
			query += " RETURNING #{returning.join(',')}"
			return query_row(query, *vals)
		end
	end

	def insert_row(table, values)
		pk_name = get_primarykey_name(table)
		if values.has_key?(pk_name)
			insert(table, values)
		else
			results = insert(table, values, [pk_name])
			values[pk_name] = results[pk_name]
		end
		values
	end

	def update_one(table, set, where, returning=nil)
		setclause = set.each_key.collect { |k| "#{k}=?" }.join(",")
		whereclause = where.each_key.collect { |k| where[k].nil? ? "#{k} IS NULL" : "#{k}=?" }.join(" AND ")

		query = "UPDATE #{table} SET #{setclause} WHERE #{whereclause}"

		params = set.values + where.values.compact
		unless returning
			return dbdo(query, *params)
		else
			returning = [returning] unless returning.kind_of?(Array)
			query += " RETURNING #{returning.join(',')}"
			return query_row(query, *params)
		end

	end

	def query(query, *params)
		sth = execute(query, *params)
		while row = sth.fetch_hash
			yield row
		end
		sth.finish
	end

	def query_row(query, *params)
		sth = execute(query, *params)

		row = sth.fetch_hash
		if row == nil
			sth.finish
			return nil
		elsif sth.fetch_hash != nil
			sth.finish
			raise "More than one result when querying for #{query}."
		else
			sth.finish
			return row
		end
	end
end

class FSNode
	def initialize(type, path, parent=nil)
		@data = {}
		@type = type
		@path = _fixup_path(path)
		@name = File.basename(@path)
		@parent = parent
		if @parent.nil?
			raise "No parent but we are not /." unless @path == "/"
			@parent = self
		elsif not @parent.kind_of? FSNodeDirectory
			raise "FSNode got a parent of wrong type (#{parent.class})."
		end
	end

	def _fixup_path(path)
		return '/' if path == '.'
		return path[1..-1] if path[0..0] == '.'
		raise "Unexpected path(#{path}) for fixup"
	end

	def to_s
		"#{@type} #{@path}"
	end

	def new_db_node(db, mirrorrun_id)
		node = { 'first'  => mirrorrun_id,
		         'last'   => mirrorrun_id
		       }
		node['parent'] = @parent.directory_id(db)
		db.insert_row('node', node)
		return node['node_id']
	end


	def update_one_side(db, mirrorrun_id, lastnext, lastnext_id, table, whereclause, whereparams, isrootdir)
		query = "UPDATE node SET #{lastnext}=?
		         FROM #{table}
		         WHERE node.node_id = #{table}.node_id " +
		         (isrootdir ? "" : "AND parent=? ") +
		         "AND #{lastnext}=? AND
		         #{whereclause}"
		args = [mirrorrun_id] +
		       (isrootdir ? [] : [@parent.directory_id()]) +
		       [lastnext_id] +
		       whereparams

		if self.kind_of? FSNodeDirectory
			query += ' RETURNING directory_id'
			r = db.query_row(query, *args)
			@directory_id = r['directory_id'] if r
			return r
		else
			r = db.dbdo(query, *args)
			raise "Did not update exactly zero or one element." if r and r>1
			return r
		end
	end

	def insert(db, mirrorrun_id)
		new_node_id = new_db_node(db, mirrorrun_id)
		insert_elem(db, new_node_id)
	end

	def update_or_insert(db, mirrorrun_id, prev_run, next_run)
		table, whereclause, whereparams = already_exists_args
		isrootdir = @parent == self

		[ ['last', prev_run], ['first', next_run] ].each do |lastnext, lastnext_id|
			next if lastnext_id.nil?
			r = update_one_side(db, mirrorrun_id, lastnext, lastnext_id, table, whereclause, whereparams, isrootdir)
			return if r
		end

		#XXX
		# boxed case still missing

		insert(db, mirrorrun_id)
	end
end

class FSNodeDirectory < FSNode
	def initialize(path, parent=nil)
		super('d', path, parent)
	end

	def directory_id(db=nil)
		return @directory_id if @directory_id
		throw "This should only be required for the / directory.  This is #{@path}." unless @path == "/"
		@directory_id = db.query_row("SELECT nextval(pg_get_serial_sequence('directory', 'directory_id')) AS newref")['newref']
		$logger.debug("Making up directory_id for #{@path}.  It's #{@directory_id}.")
		return @directory_id
	end

	def already_exists_args()
		return 'directory', "path=?", [@path]
	end

	def insert_elem(db, node_id)
		dir = { 'path'    => @path,
		        'node_id' => node_id
		      }
		dir['directory_id'] = @directory_id if @directory_id
		db.insert_row('directory', dir)
		@directory_id = dir['directory_id']
	end
end

class FSNodeSymlink < FSNode
	def initialize(path, target, parent=nil)
		super('l', path, parent)
		@target = target
	end
	def to_s
		super + " #{@target}"
	end

	def already_exists_args()
		return 'symlink', "name=? AND target=?", [@name, @target]
	end

	def insert_elem(db, node_id)
		elem = { 'name'    => @name,
		         'target'  => @target,
		         'node_id' => node_id
		       }
		db.insert_row('symlink', elem)
	end
end

class FSNodeRegular < FSNode
	def initialize(path, truepath, statinfo, parent=nil, digest=nil)
		super('-', path, parent)
		@truepath = truepath
		@size = statinfo.size
		@time = [statinfo.mtime, statinfo.ctime].max
		@digest = digest if digest
	end

	def to_s
		@digest.nil? ?
			(super + " #{@size} #{@time}") :
			(super + " #{@size} #{@time} #{@digest}")
	end

	def already_exists_args()
		if @digest.nil?
			return 'file', "name=? AND size=?", [@name, @size]
		else
			return 'file', "name=? AND size=? AND hash=?", [@name, @size, @digest]
		end
	end

	def insert_elem(db, node_id)
		@digest = Digest::SHA1.hexdigest( File.open(@truepath).read )
		elem = { 'name'    => @name,
		         'size'    => @size,
		         'hash'    => @digest,
		         'node_id' => node_id
		       }
		db.insert_row('file', elem)
	end
end

class FSReader
	def initialize(path)
		@root = path
	end

	def each_node(path='.', parent=nil)
		realpath = "#{@root}/#{path}"
		dir = FSNodeDirectory.new(path, parent)
		yield dir

		Dir.foreach(realpath) do |filename|
			next if %w{. ..}.include? filename
			element = "#{path}/#{filename}"
			trueelement = "#{@root}/#{element}"

			statinfo = File.lstat(trueelement)
			if statinfo.symlink?
				yield FSNodeSymlink.new(element, File.readlink(trueelement), dir)
			elsif statinfo.directory?
				each_node(element, dir) { |e| yield e}
			elsif statinfo.file?
				yield FSNodeRegular.new(element, trueelement, statinfo, dir)
			else
				$logger.warn("Ignoring #{element} which has unknown file type.")
			end
		end
	end
end

class SnapshotImporter
	def initialize(db, archive, path, date)
		@db = db
		r = @db.query_row('SELECT archive_id FROM archive WHERE name=?', archive)
		barf("Archive #{archive} does not exist") if archive.nil?
		@archive = archive
		@archive_id = r['archive_id']
		@fs = FSReader.new(path)
		@date = date.nil? ? Time.new() : Time.parse(date)
	end

	def import
		@db.begin
		mirrorrun_id = @db.insert_row('mirrorrun', {'archive_id'=>@archive_id, 'run'=>@date})['mirrorrun_id']

		row = @db.query_row("SELECT
		                       (SELECT count(*) FROM mirrorrun WHERE archive_id=?
		                        AND run=(SELECT run FROM mirrorrun WHERE mirrorrun_id=?)) AS count,
		                       (SELECT mirrorrun_id FROM mirrorrun WHERE archive_id=?
		                        AND run>(SELECT run FROM mirrorrun WHERE mirrorrun_id=?)
		                        ORDER BY run
		                        LIMIT 1) AS next,
		                       (SELECT mirrorrun_id FROM mirrorrun WHERE archive_id=?
		                        AND run<(SELECT run FROM mirrorrun WHERE mirrorrun_id=?)
		                        ORDER BY run DESC
		                        LIMIT 1) AS prev
		                    ", @archive_id, mirrorrun_id, @archive_id, mirrorrun_id, @archive_id, mirrorrun_id);
		barf("Cannot have two runs for the same archive at the same time.") if row['count'] > 1
		next_run, prev_run = row['next'], row['prev']
		$logger.info("New mirrorrun #{mirrorrun_id} for #{@archive}")

		@fs.each_node do |fsnode|
			fsnode.update_or_insert(@db, mirrorrun_id, prev_run, next_run)
			$logger.debug("Importing #{fsnode}")
		end
		@db.query('SELECT * from node where parent=-1') do |r|
			puts r.inspect
		end
		@db.commit
	end

end

class Snapshot
	def initialize(conf)
		@db = SnapshotDB.new(conf['db'])
	end

	def list_archives()
		@db.query("SELECT name FROM archive ORDER BY name") { |row|
			puts row['name']
		}
	end

	def add_archive(options)
		barf("No archive name given") unless options['archive']
		@db.begin
		@db.insert_row('archive', {'name' => options['archive']})
		@db.commit
		$logger.info("Added new archive #{options['archive']}.")
	end

	def fs_list(options)
		barf("No path name given") unless options['path']
		fs = FSReader.new(options['path'])
		fs.each_node() { |p| puts p }
	end

	def import(options)
		barf("No path name given") unless options['path']
		barf("No archive name given") unless options['archive']
		fs = SnapshotImporter.new(@db, options['archive'], options['path'], options['date'])
		fs.import
	end
end


def makeLogger(conf, options)
	if options['log-to-stderr']
		logger = Logger.new(STDOUT)
	else
		barf("Configuration does not have a log->filename.") unless conf and conf['filename']
		logger = Logger.new(conf['filename'], shift_age = 'weekly')
	end

	if options['quiet']
		logger.level = Logger::WARN
	elsif options['verbose']
		logger.level = Logger::DEBUG
	else
		logger.level = Logger::INFO
	end

	logger.datetime_format = "%Y-%m-%d %H:%M:%S"

	return logger
end

def loadConfig(file)
	begin
		config = YAML::load( File.open( file ) )
	rescue
		barf("Cannot load config: #{$!}.")
	end
end


def show_help(parser, code=0, io=STDOUT)
	program_name = File.basename($0, '.*')
	io.puts "Usage: #{program_name} [options] <action>"
	io.puts "  Where action is one of the following:"
	io.puts "    list-archives                    List all known archives"
	io.puts "    add-archive                      Add a new archive"
	io.puts "    fs-list                          List a directory recursively"
	io.puts "    import                           Import a directory"
	io.puts "  Options:"
	io.puts parser.summarize
	exit(code)
end

options = {}
ARGV.options do |opts|
	opts.on_tail("-c", "--config=<f>"   , String, "Config file")                 { |options['config']| }
	opts.on_tail("-s", "--log-to-stderr", nil,    "Log to stderr instead of the configure logfile") { |options['log-to-stderr']| }
	opts.on_tail("-q", "--quiet"        , nil,    "Do not show info level notices")                 { |options['quiet']| }
	opts.on_tail("-v", "--verbose"      , nil,    "Be more verbose")                                { |options['verbose']| }
	opts.on_tail("-a", "--archive=<a>"  , String, "Archive to add/operate on")                      { |options['archive']| }
	opts.on_tail("-p", "--path=<p>"     , String, "Path to recurse/import")                         { |options['path']| }
	opts.on_tail("-d", "--date=<d>"     , String, "Date associated with an import (if not 'now')")  { |options['date']| }

	opts.on_tail("-h", "--help", "Display this help screen")        { show_help(opts) }
	opts.parse!
end




show_help(ARGV.options, 1, STDERR) unless options['config']
show_help(ARGV.options, 1, STDERR) unless ARGV.length == 1
action = ARGV.shift

config = loadConfig(options['config'])
$logger = makeLogger(config['log'], options)
snapshot = Snapshot.new(config)

case action
	when "list-archives"
		snapshot.list_archives
	when "add-archive"
		snapshot.add_archive(options)
	when "fs-list"
		snapshot.fs_list(options)
	when "import"
		snapshot.import(options)
	else
		barf("Unknown action #{action}.")
end

# vim:set ts=4:
# vim:set shiftwidth=4:
