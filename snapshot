#!/usr/bin/ruby

# Copyright (c) 2009 Peter Palfrader
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


require 'optparse'
require 'yaml'
require 'dbi'
require 'logger'

def barf(str)
	STDERR.puts str
	exit 1
end

class SnapshotDB
	def initialize(conf)
		@dbh = DBI.connect("dbi:Pg:#{conf['database']}:#{conf['host']}", conf['user'], conf['password'], 'AutoCommit'=>false)
	end

	def get_primarykey_name(table);
		# XXX
		return table+'_id';
	end


	def begin()
		@dbh.do("BEGIN")
	end
	def commit()
		@dbh.do("COMMIT")
	end

	def dbdo(query, *args)
		@dbh.do(query, *args)
	end
	def execute(query, *args)
		@dbh.execute(query, *args)
	end

	def insert(table, values, returning=nil)
		cols = values.keys()
		vals = values.values()
		qmarks = ['?'] * cols.length

		query = "INSERT INTO #{table} (#{cols.join(',')}) VALUES (#{qmarks.join(',')})"

		if returning.nil?
			dbdo(query, vals)
			return nil
		else
			returning = [returning] unless returning.kind_of?(Array)
			query += " RETURNING #{returning.join(',')}"
			return query_row(query, *vals)
		end
	end

	def insert_row(table, values)
		pk_name = get_primarykey_name(table)
		if values.has_key?(pk_name)
			insert(table, values)
		else
			results = insert(table, values, [pk_name])
			values[pk_name] = results[pk_name]
		end
	end

	def query(query, *params)
		sth = execute(query, *params)
		while row = sth.fetch_hash
			yield row
		end
		sth.finish
	end

	def query_row(query, *params)
		sth = execute(query, *params)

		row = sth.fetch_hash
		if row == nil
			sth.finish
			return nil
		elsif sth.fetch_hash != nil
			sth.finish
			raise "More than one result when querying for #{query}."
		else
			sth.finish
			return row
		end
	end
end

class FSNode
	def initialize(type, path)
		@data = {}
		@type = type
		@path = _fixup_path(path)
	end

	def _fixup_path(path)
		return '/' if path == '.'
		return path[1..-1] if path[0..0] == '.'
		raise "Unexpected path(#{path}) for fixup"
	end

	def to_s
		"#{@type} #{@path}"
	end
end

class FSNodeDirectory < FSNode
	def initialize(path)
		super('d', path)
	end

end

class FSNodeSymlink < FSNode
	def initialize(path, target)
		super('l', path)
		@target = target
	end
	def to_s
		super + " #{@target}"
	end
end

class FSNodeRegular < FSNode
	def initialize(path, statinfo, digest=nil)
		super('-', path)
		@size = statinfo.size
		@time = [statinfo.mtime, statinfo.ctime].max
		@digest = digest if digest
	end

	def to_s
		@digest.nil? ?
			(super + " #{@size} #{@time}") :
			(super + " #{@size} #{@time} #{@digest}")
	end
end

class FSReader
	def initialize(path)
		@root = path
	end

	def list(path='.')
		realpath = "#{@root}/#{path}"
		yield FSNodeDirectory.new(path)

		Dir.foreach(realpath) do |filename|
			next if %w{. ..}.include? filename
			element = "#{path}/#{filename}"
			trueelement = "#{@root}/#{element}"

			statinfo = File.lstat(trueelement)
			if statinfo.symlink?
				yield FSNodeSymlink.new(element, File.readlink(trueelement))
			elsif statinfo.directory?
				list(element) { |e| yield e}
			elsif statinfo.file?
				yield FSNodeRegular.new(element, statinfo)
			else
				$logger.warn("Ignoring #{element} which has unknown file type.")
			end
		end
	end
end


class Snapshot
	def initialize(conf)
		@db = SnapshotDB.new(conf['db'])
	end

	def list_archives()
		@db.query("SELECT name FROM archive ORDER BY name") { |row|
			puts row['name']
		}
	end

	def add_archive(options)
		barf("No archive name given") unless options['archive']
		@db.begin
		@db.insert_row('archive', {'name' => options['archive']})
		@db.commit
		$logger.info("Added new archive #{options['archive']}.")
	end

	def fs_list(options)
		barf("No path name given") unless options['path']
		fs = FSReader.new(options['path'])
		fs.list() { |p| puts p }
	end
end


def makeLogger(conf, options)
	if options['log-to-stderr']
		logger = Logger.new(STDOUT)
	else
		barf("Configuration does not have a log->filename.") unless conf and conf['filename']
		logger = Logger.new(conf['filename'], shift_age = 'weekly')
	end

	if options['quiet']
		logger.level = Logger::WARN
	elsif options['verbose']
		logger.level = Logger::DEBUG
	else
		logger.level = Logger::INFO
	end

	logger.datetime_format = "%Y-%m-%d %H:%M:%S"

	return logger
end

def loadConfig(file)
	begin
		config = YAML::load( File.open( file ) )
	rescue
		barf("Cannot load config: #{$!}.")
	end
end


def show_help(parser, code=0, io=STDOUT)
	program_name = File.basename($0, '.*')
	io.puts "Usage: #{program_name} [options] <action>"
	io.puts "  Where action is one of the following:"
	io.puts "    list-archives                    List all known archives"
	io.puts "    add-archive                      Add a new archive"
	io.puts "    fs-list                          List a directory recursively"
	io.puts "  Options:"
	io.puts parser.summarize
	exit(code)
end

options = {}
ARGV.options do |opts|
	opts.on_tail("-c", "--config=<f>"   , String, "Config file")                 { |options['config']| }
	opts.on_tail("-s", "--log-to-stderr", nil,    "Log to stderr instead of the configure logfile") { |options['log-to-stderr']| }
	opts.on_tail("-q", "--quiet"        , nil,    "Do not show info level notices")                 { |options['quiet']| }
	opts.on_tail("-v", "--verbose"      , nil,    "Be more verbose")                                { |options['verbose']| }
	opts.on_tail("-a", "--archive=<a>"  , String, "Archive to add/operate on")                      { |options['archive']| }
	opts.on_tail("-p", "--path=<a>"     , String, "Path to recurse/import")                         { |options['path']| }

	opts.on_tail("-h", "--help", "Display this help screen")        { show_help(opts) }
	opts.parse!
end




show_help(ARGV.options, 1, STDERR) unless options['config']
show_help(ARGV.options, 1, STDERR) unless ARGV.length == 1
action = ARGV.shift

config = loadConfig(options['config'])
$logger = makeLogger(config['log'], options)
snapshot = Snapshot.new(config)

case action
	when "list-archives"
		snapshot.list_archives
	when "add-archive"
		snapshot.add_archive(options)
	when "fs-list"
		snapshot.fs_list(options)
	else
		barf("Unknown action #{action}.")
end

# vim:set ts=4:
# vim:set shiftwidth=4:
